<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Minesweeper-klipse</title>
<link rel="stylesheet" type="text/css" href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css">
<script>
    window.klipse_settings = {
        selector: '.language-klipse',
        selector_reagent: '.language-reagent',
    };
</script>
</head>
<body>
<h1><center>Minesweeper-klipse</center></h1>
<h2>
<pre><code class="language-klipse">
(require '[reagent.core :as r])
</code></pre>
<pre><code class="language-klipse">
(def board-width 12)
(def board-height 12)
(def num-mines 18)

(def rand-positions
  (shuffle
   (for [i (range board-width)
         j (range board-height)]
     [i j])))
</code></pre>

<pre><code class="language-klipse">
(def mines
  (loop [squares (repeat num-mines 1)]
    (if (= (count squares) (* board-width board-height))
      squares
      (recur (conj squares 0)))))
</code></pre>

<pre><code class="language-klipse">
(def minefield
  (into {}
        (map vector
             rand-positions
             mines)))
</code></pre>
<pre><code class="language-klipse">
(def app-state
  (r/atom
   {:matrix minefield
    :stepped []
    :game-status :in-progress
    :message "Tread lightly..."}))
</code></pre>
<pre><code class="language-klipse">
(defn mine? [x y]
  (= 1 (get (:matrix @app-state) [x y])))
</code></pre>
<pre><code class="language-klipse">
(defn top-left? [x y n]
  (if (mine? (dec x) (dec y))
    [x y (inc n)]
    [x y n]))

(defn top? [x y n]
  (if (mine? x (dec y))
    [x y (inc n)]
    [x y n]))

(defn top-right? [x y n]
  (if (mine? (inc x) (dec y))
    [x y (inc n)]
    [x y n]))

(defn right? [x y n]
  (if (mine? (inc x) y)
    [x y (inc n)]
    [x y n]))

(defn bottom-right? [x y n]
  (if (mine? (inc x) (inc y))
    [x y (inc n)]
    [x y n]))

(defn bottom? [x y n]
  (if (mine? x (inc y))
    [x y (inc n)]
    [x y n]))

(defn bottom-left? [x y n]
  (if (mine? (dec x) (inc y))
    [x y (inc n)]
    [x y n]))

(defn left? [x y n]
  (if (mine? (dec x) y)
    [x y (inc n)]
    [x y n]))

(defn mine-detector [x y]
  (->> [x y 0]
    (apply top-left?)
    (apply top?)
    (apply top-right?)
    (apply right?)
    (apply bottom-right?)
    (apply bottom?)
    (apply bottom-left?)
    (apply left?)
    last))
</code></pre>
<pre><code class="language-klipse">
(defn step! [x y]
  (swap! app-state assoc-in [:stepped]
         (conj (:stepped @app-state) [x y])))
</code></pre>
<pre><code class="language-klipse">
(defn clear-squares [x y] 
  (swap! app-state assoc-in [:stepped]
         (conj (:stepped @app-state) 
               [(dec x) (dec y)]
               [x (dec y)]
               [x (inc y)]
               [(dec x) y]
               [(inc x) y] 
               [(inc x) (dec y)]
               [(inc x) (inc y)]
               [(dec x) (inc y)])))
</code></pre>
<pre><code class="language-klipse">
(defn valid-square? [[x y]]
  (and (<= 0 x (dec board-width))
       (<= 0 y (dec board-width))))

(defn filter-squares [[x y]]
  (filter valid-square? (distinct (:stepped @app-state))))

(defn win? []
  (= num-mines
     (-  (* board-height board-width)
         (count (filter-squares (:stepped @app-state))))))
</code></pre>
<pre><code class="language-reagent">
(defn blank [x y]
  [:rect
   {:width 0.9
    :height 0.9
    :fill "grey"
    :x (+ 0.05 x)
    :y (+ 0.05 y)
    :on-click
    (fn blank-click [e]
      (when (= (:game-status @app-state) :in-progress)
        (step! x y)
        (if (win?)
          (do (swap! app-state assoc :game-status :win)
            (swap! app-state assoc :message "Congratulations!")))
        (if (= 1 (get (:matrix @app-state) [x y]))
          (do (swap! app-state assoc :game-status :dead)
            (swap! app-state assoc :message "Fuck. You blew up."))
          (if (zero? (mine-detector x y))
            (clear-squares x y)))))}])

(defn rect-cell
  [x y]
  [:rect.cell
   {:x (+ 0.05 x) :width 0.9
    :y (+ 0.05 y) :height 0.9
    :fill "white"
    :stroke-width 0.025
    :stroke "black"}])

(defn text-cell [x y]
  [:text
   {:x (+ 0.5 x) :width 1
    :y (+ 0.72 y) :height 1
    :text-anchor "middle"
    :font-size 0.6}
   (if (zero? (mine-detector x y))
     ""
     (str (mine-detector x y)))])

(defn cross [i j]
  [:g {:stroke "darkred"
       :stroke-width 0.4
       :stroke-linecap "round"
       :transform
       (str "translate(" (+ 0.5 i) "," (+ 0.5 j) ") "
            "scale(0.3)")}
   [:line {:x1 -1 :y1 -1 :x2 1 :y2 1}]
   [:line {:x1 1 :y1 -1 :x2 -1 :y2 1}]])

(defn render-board []
  (into
   [:svg.board
    {:view-box (str "0 0 " board-width " " board-height)
     :shape-rendering "auto"
     :style {:max-height "500px"}}]
   (for [i (range board-width)
         j (range board-height)]
     [:g
      [rect-cell i j]
      (if (some #{[i j]} (:stepped @app-state))
        (if (= 1 (get (:matrix @app-state) [i j]))
          [cross i j]
          [text-cell i j])      
        [blank i j])])))

(defn mine []
  [:center
   [:h1 (:message @app-state)]
   [:button
    {:on-click
     (fn new-game-click [e]
       (swap! app-state assoc
              :matrix minefield
              :message "Welcome back"
              :game-status :in-progress
              :stepped []))}
    "Reset"]
   [:div [render-board]]])

[mine]
</code></pre>
</h2>
<script src="https://storage.googleapis.com/app.klipse.tech/plugin/js/klipse_plugin.js"></script>
</body>
</html>
